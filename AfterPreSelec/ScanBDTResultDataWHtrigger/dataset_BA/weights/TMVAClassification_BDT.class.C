// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.26/06       [399878]
Creator        : yxiang
Date           : Fri Aug 11 10:04:47 2023
Host           : Darwin Ventura-arm64.local 22.1.0 Darwin Kernel Version 22.1.0: Sun Oct 9 20:15:37 PDT 2022; root:xnu-8792.41.9~2/RELEASE_ARM64_VMAPPLE arm64
Dir            : /Users/yxiang/Analysis/result/23_08_10/Combination_s2H1W3Mlb4_R25/BDT/C2V_2_BDT_v7/TBAMD3NTr50PU095
Training events: 13759
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "-1" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
NodePurityLimit: "9.500000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "crossentropy" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "False" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 8
VBSjet1pt                     VBSjet1pt                     VBSjet1pt                     VBSjet1pt                                                       'F'    [30,2210]
VBSjet1eta                    VBSjet1eta                    VBSjet1eta                    VBSjet1eta                                                      'F'    [-5.01953125,5.05078125]
VBSjet1phi                    VBSjet1phi                    VBSjet1phi                    VBSjet1phi                                                      'F'    [-3.14111328125,3.140625]
VBSjet2pt                     VBSjet2pt                     VBSjet2pt                     VBSjet2pt                                                       'F'    [30,1905]
VBSjet2eta                    VBSjet2eta                    VBSjet2eta                    VBSjet2eta                                                      'F'    [-4.77734375,4.63671875]
VBSjet2phi                    VBSjet2phi                    VBSjet2phi                    VBSjet2phi                                                      'F'    [-3.14158368111,3.14013671875]
VBSMjj                        VBSMjj                        VBSMjj                        VBSMjj                                                          'F'    [19.9339962006,8120.01269531]
VBSdetajj                     VBSdetajj                     VBSdetajj                     VBSdetajj                                                       'F'    [0,9.2177734375]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTNode

#ifndef BDTNode__def
#define BDTNode__def

class BDTNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 8 )
   {
      // the training input variables
      const char* inputVars[] = { "VBSjet1pt", "VBSjet1eta", "VBSjet1phi", "VBSjet2pt", "VBSjet2eta", "VBSjet2phi", "VBSMjj", "VBSdetajj" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[8];
   double fVmax[8];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[8];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetPurity();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDT::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(0.612672779527565);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.960503,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.884474,-99) , 
7, 5.92432, 0, 0, 0.943068,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.706556,-99) , 
6, 1106.06, 0, 0, 0.89718,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.442691,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.348755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.118413,-99) , 
1, 2.5708, 0, 0, 0.145885,-99) , 
7, 3.88171, 0, 0, 0.189108,-99) , 
7, 4.71368, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.306988);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.927947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.844682,-99) , 
0, 51.8594, 0, 0, 0.904202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.749395,-99) , 
6, 1468.37, 0, 0, 0.852716,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.61586,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404431,-99) , 
0, 69.4062, 0, 0, 0.534418,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.509953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.219664,-99) , 
1, -2.14478, 1, 0, 0.284224,-99) , 
7, 4.09839, 0, 0, 0.347928,-99) , 
7, 5.36877, 0, 0, 0.506911,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.206688);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.876424,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.77265,-99) , 
0, 51.8594, 0, 0, 0.846654,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.700815,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.604089,-99) , 
6, 1106.06, 0, 0, 0.648526,-99) , 
6, 1468.49, 0, 0, 0.763379,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.588533,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480714,-99) , 
0, 159.062, 1, 0, 0.548083,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.526707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.264303,-99) , 
4, -1.5238, 1, 0, 0.329851,-99) , 
4, 1.5127, 0, 0, 0.370717,-99) , 
7, 5.04065, 0, 0, 0.50653,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.169992);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.859125,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.803605,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.646367,-99) , 
4, -2.32349, 1, 0, 0.70064,-99) , 
6, 2079.29, 0, 0, 0.755828,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.568224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.338574,-99) , 
0, 54.4062, 0, 0, 0.504493,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.61497,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.283539,-99) , 
1, -2.5144, 1, 0, 0.341964,-99) , 
7, 3.38051, 0, 0, 0.405754,-99) , 
7, 5.36877, 0, 0, 0.505737,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.146651);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.871929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.71467,-99) , 
6, 2058.16, 0, 0, 0.777488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.571369,-99) , 
0, 41.2656, 0, 0, 0.726893,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.631091,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416523,-99) , 
0, 52.4062, 0, 0, 0.549488,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.509914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.259641,-99) , 
1, -1.74353, 1, 0, 0.377959,-99) , 
1, 2.38892, 0, 0, 0.421797,-99) , 
7, 5.42688, 0, 0, 0.505059,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.105649);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.890397,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.738589,-99) , 
2, -0.623352, 1, 0, 0.79518,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.66913,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.510827,-99) , 
7, 5.00925, 0, 0, 0.613544,-99) , 
7, 6.70972, 0, 0, 0.667181,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.603517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405105,-99) , 
4, 1.77734, 0, 0, 0.436446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.19731,-99) , 
0, 271.375, 1, 0, 0.410612,-99) , 
6, 943.629, 0, 0, 0.504477,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0886247);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.87323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.718659,-99) , 
2, -0.623352, 1, 0, 0.774844,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.642044,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476393,-99) , 
0, 215.875, 1, 0, 0.602378,-99) , 
7, 6.70972, 0, 0, 0.652226,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.560023,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406543,-99) , 
4, -1.49255, 1, 0, 0.442936,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.218355,-99) , 
0, 271.375, 1, 0, 0.419394,-99) , 
6, 943.629, 0, 0, 0.504089,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.109543);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.74588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.580378,-99) , 
0, 44.3906, 0, 0, 0.699378,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.583671,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489908,-99) , 
6, 1306.77, 0, 0, 0.537264,-99) , 
7, 5.44971, 0, 0, 0.640512,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.636482,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461716,-99) , 
4, 0.68927, 0, 0, 0.519723,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.50443,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.219342,-99) , 
1, -1.74353, 1, 0, 0.375354,-99) , 
1, 1.8103, 0, 0, 0.426118,-99) , 
6, 943.629, 0, 0, 0.503776,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0777276);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.848786,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.686038,-99) , 
2, -0.623352, 1, 0, 0.743455,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.616842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470036,-99) , 
0, 215.875, 1, 0, 0.581178,-99) , 
7, 6.70972, 0, 0, 0.626866,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.628146,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429584,-99) , 
1, -2.62402, 1, 0, 0.474603,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.360401,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.177835,-99) , 
0, 197.375, 1, 0, 0.320762,-99) , 
3, 76.9688, 1, 0, 0.433359,-99) , 
6, 943.629, 0, 0, 0.503368,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0710876);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.739054,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.566695,-99) , 
0, 146.188, 1, 0, 0.692322,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497083,-99) , 
3, 145.188, 1, 0, 0.646185,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.582165,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.543572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362119,-99) , 
4, -1.41516, 1, 0, 0.421017,-99) , 
4, 1.77209, 0, 0, 0.450522,-99) , 
6, 1222.18, 0, 0, 0.503133,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0783439);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.782619,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.683848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.522721,-99) , 
4, 2.16235, 0, 0, 0.59795,-99) , 
4, -2.8186, 1, 0, 0.637099,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.580175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415381,-99) , 
3, 82.6875, 1, 0, 0.541412,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.51165,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.286932,-99) , 
1, -1.74353, 1, 0, 0.410915,-99) , 
1, 2.05127, 0, 0, 0.453871,-99) , 
6, 1222.18, 0, 0, 0.502936,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0860469);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.680335,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.504453,-99) , 
0, 174.688, 1, 0, 0.641845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47001,-99) , 
3, 146.312, 1, 0, 0.604002,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.641688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471533,-99) , 
4, 0.997986, 0, 0, 0.520814,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.49793,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.184283,-99) , 
1, -1.48279, 1, 0, 0.391987,-99) , 
1, 1.3418, 0, 0, 0.445815,-99) , 
6, 943.629, 0, 0, 0.502719,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0501144);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.749987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.636697,-99) , 
6, 2013.61, 0, 0, 0.692208,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.537854,-99) , 
3, 121.031, 1, 0, 0.643073,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.613394,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.560199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403951,-99) , 
4, 1.68079, 0, 0, 0.442696,-99) , 
4, -2.2085, 1, 0, 0.465676,-99) , 
6, 1447.6, 0, 0, 0.502468,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.054549);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.733752,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.58875,-99) , 
0, 123.031, 1, 0, 0.684065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.535967,-99) , 
3, 121.031, 1, 0, 0.636677,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.63282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485992,-99) , 
0, 52.375, 0, 0, 0.562649,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.519528,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.360793,-99) , 
1, -1.99915, 1, 0, 0.434674,-99) , 
1, 2.61011, 0, 0, 0.46734,-99) , 
6, 1447.6, 0, 0, 0.502355,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0636269);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.777113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.628952,-99) , 
0, 64.6875, 0, 0, 0.687665,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.533325,-99) , 
0, 129.25, 1, 0, 0.642264,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.769806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.568635,-99) , 
6, 2079.29, 0, 0, 0.60012,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.471142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329372,-99) , 
7, 2.38635, 0, 0, 0.415319,-99) , 
4, 1.77209, 0, 0, 0.471114,-99) , 
4, -2.20996, 1, 0, 0.502236,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0544469);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.724378,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.58034,-99) , 
4, -2.95801, 1, 0, 0.634223,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.757413,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.564345,-99) , 
6, 2079.29, 0, 0, 0.594132,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.472972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.339034,-99) , 
7, 2.38635, 0, 0, 0.420457,-99) , 
4, 1.77209, 0, 0, 0.472862,-99) , 
4, -2.20996, 1, 0, 0.50211,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0396955);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.768944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.566669,-99) , 
0, 64.7188, 0, 0, 0.658832,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.520155,-99) , 
0, 156.25, 1, 0, 0.618358,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.595365,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459859,-99) , 
4, -1.80017, 1, 0, 0.487549,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312033,-99) , 
0, 293.375, 1, 0, 0.47202,-99) , 
6, 1447.6, 0, 0, 0.502004,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0490758);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.715904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.619116,-99) , 
0, 64.6875, 0, 0, 0.674088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.529016,-99) , 
3, 39.0781, 0, 0, 0.624263,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.743314,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.561526,-99) , 
6, 2079.29, 0, 0, 0.589122,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.474993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348781,-99) , 
7, 2.38635, 0, 0, 0.425716,-99) , 
4, 1.77209, 0, 0, 0.474981,-99) , 
4, -2.20996, 1, 0, 0.50193,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0400966);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.706669,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.734095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.559718,-99) , 
6, 2079.29, 0, 0, 0.586858,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.51697,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388445,-99) , 
4, -0.725525, 1, 0, 0.452892,-99) , 
4, 1.81274, 0, 0, 0.487173,-99) , 
4, -2.95801, 1, 0, 0.501843,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0371775);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.699751,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.726702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.557356,-99) , 
6, 2079.29, 0, 0, 0.583534,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.51629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392704,-99) , 
4, -0.725525, 1, 0, 0.454733,-99) , 
4, 1.81274, 0, 0, 0.487673,-99) , 
4, -2.95801, 1, 0, 0.501774,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0433372);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.745757,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.60137,-99) , 
0, 64.6875, 0, 0, 0.657395,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.50776,-99) , 
0, 129.25, 1, 0, 0.612624,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.698502,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.549232,-99) , 
6, 2079.29, 0, 0, 0.569468,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.497836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36859,-99) , 
1, 1.34119, 0, 0, 0.428523,-99) , 
4, 1.5127, 0, 0, 0.477389,-99) , 
4, -2.20996, 1, 0, 0.501712,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0322492);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.689764,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.7096,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.55509,-99) , 
6, 2079.29, 0, 0, 0.579027,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.515547,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401438,-99) , 
4, -0.725525, 1, 0, 0.45828,-99) , 
4, 1.86633, 0, 0, 0.488356,-99) , 
4, -2.95801, 1, 0, 0.501642,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0356128);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.743217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.590228,-99) , 
3, 60.9688, 0, 0, 0.634483,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.587466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450317,-99) , 
4, 1.77783, 0, 0, 0.491621,-99) , 
4, -2.20996, 1, 0, 0.517368,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3475,-99) , 
0, 293.875, 1, 0, 0.501592,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0303716);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.681786,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.705724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.548756,-99) , 
6, 2079.29, 0, 0, 0.571798,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.515142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401009,-99) , 
4, -0.725525, 1, 0, 0.459091,-99) , 
4, 1.77209, 0, 0, 0.488894,-99) , 
4, -2.95801, 1, 0, 0.501538,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0320628);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.685229,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.554962,-99) , 
3, 42.6719, 0, 0, 0.628032,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.582364,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453612,-99) , 
4, 1.77783, 0, 0, 0.492354,-99) , 
4, -2.20996, 1, 0, 0.516732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.35238,-99) , 
0, 293.875, 1, 0, 0.501494,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0263108);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.704759,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.539169,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432575,-99) , 
0, 54.4844, 0, 0, 0.50291,-99) , 
4, -2.95801, 1, 0, 0.516211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356713,-99) , 
0, 293.875, 1, 0, 0.501448,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.030349);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.700256,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.5721,-99) , 
4, -2.95801, 1, 0, 0.611302,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.581008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449589,-99) , 
4, 1.81274, 0, 0, 0.489699,-99) , 
4, -1.96912, 1, 0, 0.515793,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36018,-99) , 
0, 293.875, 1, 0, 0.501411,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0566524);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.71606,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.589484,-99) , 
7, 6.11768, 0, 0, 0.618944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418821,-99) , 
0, 39.4531, 0, 0, 0.570729,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.619269,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450357,-99) , 
0, 56.9844, 0, 0, 0.545968,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.500398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.313951,-99) , 
1, 1.3418, 0, 0, 0.397689,-99) , 
1, -2.06787, 1, 0, 0.473163,-99) , 
1, 2.61011, 0, 0, 0.50137,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0500478);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.706691,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.50877,-99) , 
0, 148.5, 1, 0, 0.618502,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.501928,-99) , 
0, 51.8594, 0, 0, 0.586142,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.625647,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.502308,-99) , 
4, 0.950867, 0, 0, 0.531238,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.512571,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.25143,-99) , 
1, -1.48059, 1, 0, 0.440447,-99) , 
1, 1.3418, 0, 0, 0.479862,-99) , 
6, 1447.6, 0, 0, 0.501295,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0256597);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.659708,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.67295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.53985,-99) , 
6, 2079.29, 0, 0, 0.557441,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.515227,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397165,-99) , 
4, -0.725525, 1, 0, 0.460847,-99) , 
4, 1.5127, 0, 0, 0.490311,-99) , 
4, -2.95801, 1, 0, 0.501228,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0244186);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.656019,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.669032,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.538834,-99) , 
6, 2079.29, 0, 0, 0.555998,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.514837,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399695,-99) , 
4, -0.725525, 1, 0, 0.461831,-99) , 
4, 1.5127, 0, 0, 0.490555,-99) , 
4, -2.95801, 1, 0, 0.501197,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0263908);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.710112,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.513706,-99) , 
6, 2069.75, 0, 0, 0.530941,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.474655,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.337597,-99) , 
3, 59.6094, 1, 0, 0.40469,-99) , 
0, 39.0156, 0, 0, 0.511506,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.352627,-99) , 
0, 362.125, 1, 0, 0.501169,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0464115);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.653502,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.556773,-99) , 
0, 64.8125, 0, 0, 0.609898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430017,-99) , 
0, 39.75, 0, 0, 0.564781,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.609561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452363,-99) , 
0, 56.9844, 0, 0, 0.541163,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.500183,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331589,-99) , 
1, 1.3418, 0, 0, 0.410042,-99) , 
1, -2.06787, 1, 0, 0.476226,-99) , 
1, 2.64624, 0, 0, 0.501139,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0225655);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.649789,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.662061,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.53786,-99) , 
6, 2079.29, 0, 0, 0.554073,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.514132,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403297,-99) , 
4, -0.725525, 1, 0, 0.463156,-99) , 
4, 1.5127, 0, 0, 0.490902,-99) , 
4, -2.95801, 1, 0, 0.501087,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0194639);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.646706,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.57995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475486,-99) , 
1, -2.64087, 1, 0, 0.504201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363282,-99) , 
0, 35.2656, 0, 0, 0.491103,-99) , 
4, -2.95801, 1, 0, 0.501063,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0235352);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.698824,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.512772,-99) , 
6, 2069.75, 0, 0, 0.528965,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.478697,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.344979,-99) , 
3, 59.6094, 1, 0, 0.410561,-99) , 
0, 39.0156, 0, 0, 0.510743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361314,-99) , 
0, 362.125, 1, 0, 0.501043,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0413234);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.645526,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.553145,-99) , 
0, 64.8125, 0, 0, 0.60379,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435938,-99) , 
0, 39.75, 0, 0, 0.561666,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.6009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453074,-99) , 
0, 55.8594, 0, 0, 0.538269,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.500761,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.340072,-99) , 
1, 1.3418, 0, 0, 0.415087,-99) , 
1, -2.06787, 1, 0, 0.477282,-99) , 
1, 2.64624, 0, 0, 0.501019,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0207469);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.641704,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.655559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.536843,-99) , 
6, 2079.29, 0, 0, 0.552189,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.513966,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406667,-99) , 
4, -0.725525, 1, 0, 0.464656,-99) , 
4, 1.5127, 0, 0, 0.49138,-99) , 
4, -2.95801, 1, 0, 0.500978,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0365632);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.680711,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.573602,-99) , 
7, 6.11768, 0, 0, 0.598005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431853,-99) , 
0, 39.4531, 0, 0, 0.557792,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.637347,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466947,-99) , 
0, 56.9844, 0, 0, 0.551992,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.494036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38217,-99) , 
6, 453.446, 0, 0, 0.429226,-99) , 
1, -2.64087, 1, 0, 0.47783,-99) , 
1, 2.61011, 0, 0, 0.500958,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0199483);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.692084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.557425,-99) , 
3, 60.9219, 0, 0, 0.596496,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.546709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452031,-99) , 
4, 1.14929, 0, 0, 0.491485,-99) , 
4, -2.20996, 1, 0, 0.510016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36974,-99) , 
0, 362.125, 1, 0, 0.500925,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0204188);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.682016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.515779,-99) , 
6, 2069.75, 0, 0, 0.530152,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.483054,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.35192,-99) , 
3, 59.6094, 1, 0, 0.416332,-99) , 
0, 39.0156, 0, 0, 0.512103,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389713,-99) , 
0, 293.875, 1, 0, 0.500907,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0212949);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.634573,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.652991,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.528474,-99) , 
6, 2079.29, 0, 0, 0.542048,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.513805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389088,-99) , 
4, -0.725525, 1, 0, 0.462892,-99) , 
4, 1.14929, 0, 0, 0.491813,-99) , 
4, -2.95801, 1, 0, 0.500889,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0196326);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.680534,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.51185,-99) , 
6, 2069.75, 0, 0, 0.526345,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.483088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354743,-99) , 
3, 59.6094, 1, 0, 0.417813,-99) , 
0, 39.0156, 0, 0, 0.509634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.374186,-99) , 
0, 362.125, 1, 0, 0.500871,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0404752);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.63412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.545217,-99) , 
0, 64.8125, 0, 0, 0.593854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442908,-99) , 
0, 39.75, 0, 0, 0.555915,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.577535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445792,-99) , 
0, 56.9844, 0, 0, 0.526198,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.503522,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.290634,-99) , 
1, 1.3418, 0, 0, 0.41146,-99) , 
1, -1.48022, 1, 0, 0.479312,-99) , 
1, 2.64624, 0, 0, 0.500854,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0306981);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.711759,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.520824,-99) , 
0, 54.5, 0, 0, 0.603568,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.549579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426552,-99) , 
1, 1.3418, 0, 0, 0.493969,-99) , 
1, -3.18286, 1, 0, 0.514126,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.469662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.294075,-99) , 
7, 2.98369, 0, 0, 0.414681,-99) , 
3, 145.562, 1, 0, 0.500818,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0154528);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.628807,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.593324,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484594,-99) , 
1, -3.18286, 1, 0, 0.503954,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376456,-99) , 
0, 35.2656, 0, 0, 0.49212,-99) , 
4, -2.95801, 1, 0, 0.500794,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0172755);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.626947,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.641731,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.53434,-99) , 
6, 2079.29, 0, 0, 0.548013,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.513224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413964,-99) , 
4, -0.725525, 1, 0, 0.467689,-99) , 
4, 1.5127, 0, 0, 0.49224,-99) , 
4, -2.95801, 1, 0, 0.500782,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0243592);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.660064,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476684,-99) , 
3, 78.3438, 1, 0, 0.59673,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.545843,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431463,-99) , 
1, 1.3418, 0, 0, 0.492373,-99) , 
1, -3.18237, 1, 0, 0.510709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400605,-99) , 
0, 35.0469, 0, 0, 0.500769,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0278778);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.702608,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.517731,-99) , 
0, 54.5, 0, 0, 0.59747,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.547314,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430835,-99) , 
1, 1.3418, 0, 0, 0.494684,-99) , 
1, -3.18286, 1, 0, 0.513521,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.471142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.300849,-99) , 
7, 2.98369, 0, 0, 0.418029,-99) , 
3, 145.562, 1, 0, 0.500751,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0268366);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.611539,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440176,-99) , 
3, 102.906, 1, 0, 0.573402,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.543872,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402543,-99) , 
1, 1.3418, 0, 0, 0.487398,-99) , 
1, -2.64087, 1, 0, 0.510473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40259,-99) , 
0, 35.0469, 0, 0, 0.500731,-99)    );
   return;
};

// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
